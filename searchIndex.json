[
{
		"title": "Digital Garden Home",
		"date":"Mon Jul 14 2025 06:23:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "üè°\nWelcome\nHi, welcome to my digital garden.\nEnjoy!",
		"tags": [ "note","#article","#Blogs","gardenEntry"]
},

{
		"title": "Bash Notes",
		"date":"Mon Jul 14 2025 06:23:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/resources/it/linux/bash-notes/",
		"content": "Get script BASE_DIR\ncloude.ai\n#!/bin/bash\n\n# Get the directory of the script\nget_script_dir() {\n# Get the source directory\nSOURCE=&quot;${BASH_SOURCE[0]}&quot;\n\n# Resolve $SOURCE until the file is no longer a symlink\nwhile [ -h &quot;$SOURCE&quot; ]; do\nDIR=&quot;$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &amp;&amp; pwd )&quot;\nSOURCE=&quot;$(readlink &quot;$SOURCE&quot;)&quot;\n# If $SOURCE was a relative symlink, we need to resolve it\n# relative to the path where the symlink file was located\n[[ $SOURCE != /* ]] &amp;&amp; SOURCE=&quot;$DIR/$SOURCE&quot;\ndone\n\n# Get the canonical path of the script directory\nDIR=&quot;$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &amp;&amp; pwd )&quot;\n\necho &quot;$DIR&quot;\n}\n\n# Call the function and store the result\nSCRIPT_DIR=$(get_script_dir)\n\n# Print the result\necho &quot;The script is located in: $SCRIPT_DIR&quot;\n\n# You can use $SCRIPT_DIR for further operations in your script\n# For example:\n# cd &quot;$SCRIPT_DIR&quot;\n# ... (rest of your script)\n\nstackoverflow\n#!/usr/bin/env bash\n\nSCRIPT_DIR=$( cd -- &quot;$( dirname -- &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;&gt; /dev/null &amp;&amp; pwd )\n\nis a useful one-liner which will give you the full directory name of the script no matter where it is being called from.\nIt will work as long as the last component of the path used to find the script is not a symlink (directory links are OK). If you also want to resolve any links to the script itself, you need a multi-line solution:\n#!/usr/bin/env bash\n\nSOURCE=${BASH_SOURCE[0]}\nwhile [ -L &quot;$SOURCE&quot; ]; do # resolve $SOURCE until the file is no longer a symlink\nDIR=$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )\nSOURCE=$(readlink &quot;$SOURCE&quot;)\n[[ $SOURCE != /* ]] &amp;&amp; SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located\ndone\nDIR=$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )\n\nThis last one will work with any combination of aliases,¬†source,¬†bash -c, symlinks, etc.\nRef: https://stackoverflow.com/a/246128/1377004\nGet filename and extension\nref: https://stackoverflow.com/a/965072/1377004\nfilename=$(basename -- &quot;$fullfile&quot;)\nextension=&quot;${filename##*.}&quot;\nfilename=&quot;${filename%.*}&quot;\n\nReplace file extension\nfind . -iname &quot;*.txt&quot; -exec bash -c 'mv &quot;$0&quot; &quot;${0%\\.txt}.md&quot;' {} \\;\n\nref: https://www.reddit.com/r/ObsidianMD/comments/qgyjij/comment/kux05ai/\nAwk OFS delimiter separator\n-F: input delimiter\nOFS: output delimiter\nawk -F &quot;\\t&quot; -v OFS=&quot;|&quot; '{print $1, $2, $3}'\n\nFind file only on current dir then compress\n$ find /path/ -maxdepth 1 -type f -exec tar czf /tmp/file.tar.gz {} \\+\n\nref: https://stackoverflow.com/a/16703837/1377004\nsshfs with id_rsa\nsshfs -o allow_other,defer_permissions,IdentityFile=~/.ssh/id_rsa root@xxx.xxx.xxx.xxx:/ /mnt/droplet\n\nref: https://vtcri.kayako.com/article/86-sshfs-to-mount-remote-file-systems-over-ssh\nin fstab:\nsshfs#USER@domain.com:/data/www /mnt/logs/ fuse IdentityFile=/home/USER/.ssh/id_rsa,uid=UID,gid=GUID,users,idmap=user,noatime,allow_other,_netdev,reconnect,ro 0 0\n\nref: https://ivan.reallusiondesign.com/mount-sshfs-volumes-in-fstab-with-ssh-key/\nWhat you need to do is specify which private key to use in the¬†~/.ssh/config¬†file. for example:\nHost server1.nixcraft.com\nIdentityFile ~/backups/.ssh/id_dsa\nHost server2.nixcraft.com\nIdentityFile /backup/home/userName/.ssh/id_rsa\n\nref: https://unix.stackexchange.com/a/61571/55247\nCheck return value\n&amp;&amp; execute when return value 0\n|| execute when return value not 0\nex:\nnc -z host $PORT &amp;&amp; echo port $PORT open || echo port $PORT close\n\nRetry until succeed\nMAX_RETRIES=10\nRETRY_DELAY=60 # seconds\nCOUNT=0\n\nwhile true; do\n./your-script.sh\nif [ $? -eq 0 ]; then\necho &quot;Script succeeded.&quot;\nbreak\nfi\nCOUNT=$((COUNT+1))\nif [ $COUNT -ge $MAX_RETRIES ]; then\necho &quot;Script failed after $MAX_RETRIES attempts.&quot;\nexit 1\nfi\necho &quot;Retrying in $RETRY_DELAY seconds...&quot;\nsleep $RETRY_DELAY\ndone",
		"tags": [ "note","#awk","#delimiter","#separator","#extension"]
}
]